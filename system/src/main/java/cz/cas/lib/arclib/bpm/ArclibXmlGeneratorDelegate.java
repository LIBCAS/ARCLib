package cz.cas.lib.arclib.bpm;

import cz.cas.lib.arclib.domain.Hash;
import cz.cas.lib.arclib.domain.HashType;
import cz.cas.lib.arclib.domain.IngestToolFunction;
import cz.cas.lib.arclib.domain.ingestWorkflow.IngestEvent;
import cz.cas.lib.arclib.domain.ingestWorkflow.IngestWorkflow;
import cz.cas.lib.arclib.domain.ingestWorkflow.IngestWorkflowState;
import cz.cas.lib.arclib.domain.packages.FolderStructure;
import cz.cas.lib.arclib.domain.packages.Sip;
import cz.cas.lib.arclib.domain.preservationPlanning.Tool;
import cz.cas.lib.arclib.exception.bpm.IncidentException;
import cz.cas.lib.arclib.service.arclibxml.ArclibXmlGenerator;
import cz.cas.lib.arclib.service.arclibxml.ArclibXmlValidator;
import cz.cas.lib.arclib.service.arclibxml.systemWideValidation.SystemWideValidationMissingNodesBpmHandler;
import cz.cas.lib.arclib.service.arclibxml.systemWideValidation.SystemWideValidationNodeConfig;
import cz.cas.lib.arclib.service.fixity.Sha512Counter;
import cz.cas.lib.arclib.store.SipStore;
import cz.cas.lib.arclib.utils.ArclibUtils;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.camunda.bpm.engine.delegate.DelegateExecution;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.xml.sax.SAXException;


import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPathExpressionException;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.List;

import static cz.cas.lib.arclib.utils.ArclibUtils.filePathsToFolderStructure;
import static cz.cas.lib.core.util.Utils.bytesToHexString;

@Slf4j
@Service
public class ArclibXmlGeneratorDelegate extends ArclibDelegate {

    private ArclibXmlGenerator arclibXmlGenerator;
    private Sha512Counter sha512Counter;
    private ArclibXmlValidator validator;
    private SipStore sipStore;
    private SystemWideValidationMissingNodesBpmHandler systemWideValidationHandler;
    @Getter
    private String toolName = "ARCLib_" + IngestToolFunction.information_package_creation;

    /**
     * Generates ArclibXml according to the BPM variables stored in the <code>execution</code> and changes processingState of
     * ingest workflow to PROCESSED.
     */
    @Override
    public void executeArclibDelegate(DelegateExecution execution) throws DocumentException, IOException, ParserConfigurationException, SAXException, XPathExpressionException, IncidentException {
        String extractedMetadata = new String((byte[]) execution.getVariable(BpmConstants.MetadataExtraction.result));

        //fill size and folder structure
        Path sipZipWorkspacePath = getSipZipPath(execution);
        Path sipFolderPath = getSipFolderWorkspacePath(execution);
        FolderStructure folderStructure = filePathsToFolderStructure(ArclibUtils.listFilePaths(sipFolderPath), sipFolderPath.getFileName().toString());
        String sipId = getStringVariable(execution, BpmConstants.ProcessVariables.sipId);
        Sip sip = sipStore.find(sipId);
        sip.setSizeInBytes(Files.size(sipZipWorkspacePath));
        sip.setFolderStructure(folderStructure);
        sipStore.save(sip);

        String ingestWorkflowExternalId = getIngestWorkflowExternalId(execution);
        IngestWorkflow ingestWorkflow = ingestWorkflowService.findByExternalId(ingestWorkflowExternalId);
        Tool tool = toolService.getByNameAndVersion(getToolName(), getToolVersion());

        //prepend the metadata generated by Arclib
        IngestEvent generationEvent = new IngestEvent(ingestWorkflow, tool, true, null);
        generationEvent.setCreated(Instant.now());
        Document arclibXml = arclibXmlGenerator.generateMetadata(extractedMetadata, execution.getVariables(), generationEvent);
        String arclibXmlString = ArclibUtils.prettyPrint(arclibXml);

        //validate against ARCLib XML definition
        List<SystemWideValidationNodeConfig> missingNodes = validator.validateFinalXml(arclibXmlString, ingestWorkflow,
                getStringVariable(execution, BpmConstants.MetadataExtraction.usedSipProfile),
                getStringVariable(execution, BpmConstants.Validation.usedValidationProfile),
                false, true);
        if (!missingNodes.isEmpty()) {
            systemWideValidationHandler.handleMissingNodes(getConfigRoot(execution), false, missingNodes, ingestWorkflow, tool);
        }

        //store arclib xml to workspace
        Files.write(getAipXmlPath(execution), arclibXmlString.getBytes());
        log.debug("generated ARCLib XML was stored to the workspace: {}", getAipXmlPath(execution));

        String arclibXmlHashValue = bytesToHexString(sha512Counter.computeDigest(new ByteArrayInputStream(arclibXmlString.getBytes())));
        Hash arclibXmlHash = new Hash(arclibXmlHashValue, HashType.Sha512);
        ingestWorkflow.setArclibXmlHash(arclibXmlHash);
        log.debug("Hash of ARClibXml of Ingest workflow with external ID " + ingestWorkflowExternalId + ": "
                + arclibXmlHash.getHashValue() + ", hash type: " + arclibXmlHash.getHashType().name());

        ingestWorkflow.setProcessingState(IngestWorkflowState.PROCESSED);
        ingestWorkflowService.save(ingestWorkflow);
        ingestEventStore.save(generationEvent);

        log.info("State of ingest workflow with external id " + ingestWorkflowExternalId + " has changed to " +
                IngestWorkflowState.PROCESSED.toString() + ".");
    }

    @Autowired
    public void setSipStore(SipStore sipStore) {
        this.sipStore = sipStore;
    }

    @Autowired
    public void setValidator(ArclibXmlValidator validator) {
        this.validator = validator;
    }

    @Autowired
    public void setArclibXmlGenerator(ArclibXmlGenerator arclibXmlGenerator) {
        this.arclibXmlGenerator = arclibXmlGenerator;
    }

    @Autowired
    public void setSha512Counter(Sha512Counter sha512Counter) {
        this.sha512Counter = sha512Counter;
    }

    @Autowired
    public void setSystemWideValidationHandler(SystemWideValidationMissingNodesBpmHandler systemWideValidationHandler) {
        this.systemWideValidationHandler = systemWideValidationHandler;
    }
}
