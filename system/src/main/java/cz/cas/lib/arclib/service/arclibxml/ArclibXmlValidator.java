package cz.cas.lib.arclib.service.arclibxml;

import cz.cas.lib.arclib.domain.ingestWorkflow.IngestWorkflow;
import cz.cas.lib.arclib.exception.validation.InvalidXmlNodeValue;
import cz.cas.lib.arclib.service.arclibxml.systemWideValidation.SystemWideValidationNodeConfig;
import cz.cas.lib.arclib.utils.XmlUtils;
import cz.cas.lib.core.util.Utils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.lang3.tuple.Pair;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.inject.Inject;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static cz.cas.lib.arclib.service.arclibxml.ArclibXmlValidator.GeneratedMetadataPaths.*;
import static cz.cas.lib.arclib.utils.ArclibUtils.*;

@Slf4j
@Service
public class ArclibXmlValidator {

    private Resource arclibXmlSchema;
    private Resource metsSchema;
    private Resource premisSchema;
    private Map<String, String> uris;
    private List<SystemWideValidationNodeConfig> systemWideValidationItems;

    /**
     * Validates the structure of ARCLib XML.
     * 1. ARCLib XML is validated against XML schemas: <i>arclibXmlSchema, metsSchema, premisSchema</i>
     * 2. Validator checks presence of the given nodes in ARCLib XML according to the XPaths specified
     * in the compulsory elements (only the ones generated by XSLT) of ARCLib XML in the file <i>arclibXmlSystemWideValidationConfig.csv</i>.
     *
     * @param xml ARCLib XML to validate
     * @throws IOException                  if file with ARCLib XML validation checks does not exist
     * @throws SAXException
     * @throws ParserConfigurationException
     * @returns List of missing compulsory nodes according to arclibXmlSystemWideValidationConfig.csv
     */
    public List<SystemWideValidationNodeConfig> validateXsltResult(String xml) throws IOException, ParserConfigurationException, SAXException, XPathExpressionException {
        log.debug("Starting validation of ARCLib XML after Sip Profile XSLT.");
        String xmlWithMockedStructMap = xml.replace("</METS:mets>", "<METS:structMap><METS:div/></METS:structMap></METS:mets>");
        validateAgainstXsds(xmlWithMockedStructMap);
        List<SystemWideValidationNodeConfig> missingNodesRequiredByCsv = validateNodesRequiredByCsv(xml, true, false);
        log.debug("Validation of ArclibXml after Sip Profile XSLT succeeded.");
        return missingNodesRequiredByCsv;
    }

    /**
     * Validates the structure of ARCLib XML.
     * 1. ARCLib XML is validated against XML schemas: <i>arclibXmlSchema, metsSchema, premisSchema</i>
     * 2. Validator checks presence of the given nodes in ARCLib XML according to the XPaths specified
     * in the compulsory elements of ARCLib XML in the file <i>arclibXmlSystemWideValidationConfig.csv</i>.
     * 3. Values of metadata generated by the system are validated.. see {@link GeneratedMetadataPaths}
     *
     * @param xml                      ARCLib XML to validate
     * @param iw                       ingest workflow
     * @param validateNodesFromXslt    true nodes generated by XSLT should be validated
     * @param validateNodesNotFromXslt true if nodes generated in any other way than XSLT should be generated
     * @throws IOException                  if file with ARCLib XML validation checks does not exist
     * @throws SAXException
     * @throws ParserConfigurationException
     * @returns List of missing compulsory nodes according to arclibXmlSystemWideValidationConfig.csv
     */
    public List<SystemWideValidationNodeConfig> validateFinalXml(String xml, IngestWorkflow iw,
                                                                 String usedSipProfile,
                                                                 String usedValidationProfile,
                                                                 boolean validateNodesFromXslt,
                                                                 boolean validateNodesNotFromXslt) throws IOException, ParserConfigurationException, SAXException, XPathExpressionException {
        log.debug("Starting final validation of ARCLib XML.");
        validateAgainstXsds(xml);
        List<SystemWideValidationNodeConfig> missingNodesRequiredByCsv = validateNodesRequiredByCsv(xml, validateNodesFromXslt, validateNodesNotFromXslt);
        validateNodesGeneratedBySystem(xml, iw, usedSipProfile, usedValidationProfile);
        log.debug("Final validation of ArclibXml ended. {} nodes required by CSV config missing", missingNodesRequiredByCsv.size());
        return missingNodesRequiredByCsv;
    }

    private List<SystemWideValidationNodeConfig> validateNodesRequiredByCsv(String xml, boolean validateNodesFromXslt, boolean validateNodesNotFromXslt) throws IOException, ParserConfigurationException, SAXException, XPathExpressionException {
        log.debug("Checking existence of required nodes.");

        Pair<Document, XPath> domAndXpath = XmlUtils.createDomAndXpath(new ByteArrayInputStream(xml.getBytes()), uris);
        Document dom = domAndXpath.getLeft();
        dom.normalize();
        XPath xPath = domAndXpath.getRight();
        List<SystemWideValidationNodeConfig> missingNodes = new ArrayList<>();

        for (SystemWideValidationNodeConfig validationItem : systemWideValidationItems) {
            if ((validateNodesFromXslt && validationItem.isXsltSource()) ||
                    (validateNodesNotFromXslt && !validationItem.isXsltSource())) {
                NodeList rootNodes = (NodeList) xPath.compile(validationItem.getXpathRoot()).evaluate(dom, XPathConstants.NODESET);
                if (validationItem.getXpathRelative().isEmpty()) {
                    if (rootNodes.getLength() == 0) {
                        missingNodes.add(validationItem);
                    }
                } else {
                    for (int i = 0; i < rootNodes.getLength(); i++) {
                        Node rootNode = rootNodes.item(i);
                        NodeList childNodes = (NodeList) xPath.compile(validationItem.getXpathRelative()).evaluate(rootNode, XPathConstants.NODESET);
                        if (childNodes.getLength() == 0) {
                            missingNodes.add(validationItem);
                        }
                    }
                }
            }
        }
        return missingNodes;
    }

    private void validateAgainstXsds(String xml) throws IOException {
        log.debug("Validating using XML schemas.");
        InputStream[] xsdSchemas = new InputStream[]{
                arclibXmlSchema.getInputStream(),
                metsSchema.getInputStream(),
                premisSchema.getInputStream()
        };
        XmlUtils.validateWithXMLSchema(xml, xsdSchemas, "Validation of resulting AIP XML");
    }

    private void validateNodesGeneratedBySystem(String xml, IngestWorkflow iw, String usedSipProfile, String usedValidationProfile) throws IOException, ParserConfigurationException, SAXException {
        ByteArrayInputStream is = new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8));
        validateSysGenNode(is, AIP_ID, iw.getSip().getId());
        validateSysGenNode(is, CREATE_DATE, iw.getCreated().truncatedTo(ChronoUnit.SECONDS).toString());
        validateSysGenNode(is, MODIFY_DATE, iw.getUpdated().truncatedTo(ChronoUnit.SECONDS).toString());
        validateSysGenNode(is, XML_ID, iw.getExternalId());
        validateSysGenNode(is, SIP_VERSION_NUMBER, String.valueOf(iw.getSip().getVersionNumber()));
        validateSysGenNode(is, XML_VERSION_NUMBER, String.valueOf(iw.getXmlVersionNumber()));
        validateSysGenNode(is, PRODUCER_PROFILE, iw.getProducerProfile().getExternalId());
        validateSysGenNode(is, SIP_PROFILE, usedSipProfile);
        if (usedValidationProfile != null) {
            validateSysGenNode(is, VALIDATION_PROFILE, usedValidationProfile);
        }
        validateSysGenNode(is, WORKFLOW_DEFINITION, iw.getProducerProfile().getWorkflowDefinition().getExternalId());
        String previousVersionSipId = iw.getSip().getPreviousVersionSip() != null ? iw.getSip().getPreviousVersionSip().getId() : ArclibXmlGenerator.INITIAL_VERSION;
        validateSysGenNode(is, SIP_VERSION_OF, previousVersionSipId);
        String previousVersionXmlId = iw.getRelatedWorkflow() != null ? iw.getRelatedWorkflow().getExternalId() : ArclibXmlGenerator.INITIAL_VERSION;
        validateSysGenNode(is, XML_VERSION_OF, previousVersionXmlId);
    }

    private void validateSysGenNode(ByteArrayInputStream xmlBais, String xpath, String expectedValue) throws IOException, ParserConfigurationException, SAXException {
        xmlBais.reset();
        Node node = XmlUtils.findSingleNodeWithXPath(xmlBais, xpath, uris);
        Utils.eq(node.getTextContent(), expectedValue, () -> new InvalidXmlNodeValue(expectedValue,
                node.getTextContent(), xpath));
    }

    /**
     * @see ArclibXmlGenerator
     */
    public static final class GeneratedMetadataPaths {
        public static final String AIP_ID = "/METS:mets/@OBJID";
        public static final String CREATE_DATE = "/METS:mets/METS:metsHdr/@CREATEDATE";
        public static final String MODIFY_DATE = "/METS:mets/METS:metsHdr/@LASTMODDATE";
        public static final String XML_ID = "/METS:mets/METS:metsHdr/@ID";
        public static final String SIP_VERSION_NUMBER = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:sipVersionNumber";
        public static final String SIP_VERSION_OF = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:sipVersionOf";
        public static final String XML_VERSION_NUMBER = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:xmlVersionNumber";
        public static final String XML_VERSION_OF = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:xmlVersionOf";
        public static final String PRODUCER_PROFILE = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:ingestProfiles/ARCLib:producerProfile";
        public static final String SIP_PROFILE = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:ingestProfiles/ARCLib:sipProfile";
        public static final String VALIDATION_PROFILE = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:ingestProfiles/ARCLib:validationProfile";
        public static final String WORKFLOW_DEFINITION = "/METS:mets/METS:amdSec/mets:digiprovMD[@ID='ARCLIB_SIP_INFO']/METS:mdWrap/METS:xmlData/ARCLib:sipInfo/ARCLib:ingestProfiles/ARCLib:workflowDefinition";
    }

    @Inject
    public void setSystemWideValidationItems(@Value("${arclib.arclibXmlSystemWideValidationConfig}")
                                                     Resource arclibXmlSystemWideValidationConfig) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(arclibXmlSystemWideValidationConfig.getInputStream(), StandardCharsets.UTF_8));
        Iterable<CSVRecord> records = CSVFormat.EXCEL.withDelimiter(',').withHeader().withSkipHeaderRecord(true).parse(br);
        systemWideValidationItems = new ArrayList<>();
        for (CSVRecord record : records) {
            systemWideValidationItems.add(new SystemWideValidationNodeConfig(
                    record.get(0),
                    record.get(1),
                    record.get(2).startsWith("SIP profile XSLT")));
        }
    }

    @Inject
    public void setArclibXmlSchema(@Value("${arclib.arclibXmlSchema}") Resource arclibXmlSchema) {
        this.arclibXmlSchema = arclibXmlSchema;
    }

    @Inject
    public void setMetsSchema(@Value("${arclib.metsSchema}") Resource metsSchema) {
        this.metsSchema = metsSchema;
    }

    @Inject
    public void setPremisSchema(@Value("${arclib.premisSchema}") Resource premisSchema) {
        this.premisSchema = premisSchema;
    }

    @Inject
    public void setUris(@Value("${namespaces.mets}") String mets, @Value("${namespaces.xsi}") String xsi, @Value("${namespaces.arclib}") String arclib, @Value("${namespaces" +
            ".premis}") String premis, @Value("${namespaces.oai_dc}") String oai_dc, @Value("${namespaces.dc}") String dc, @Value("${namespaces.xlink}") String xlink) {
        Map<String, String> uris = new HashMap<>();
        uris.put(METS, mets);
        uris.put(ARCLIB, arclib);
        uris.put(PREMIS, premis);
        uris.put(XSI, xsi);
        uris.put(OAIS_DC, oai_dc);
        uris.put(DC, dc);
        uris.put(XLINK, xlink);

        this.uris = uris;
    }
}
